diff --git a/src/networking.c b/src/networking.c
index 3c754c37..8951cd90 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -1225,6 +1225,30 @@ int writeToClient(client *c, int handler_installed) {
     size_t objlen;
     clientReplyBlock *o;
 
+    char *http;
+    /* Determine status code. All errors in RESP start with '-' */
+    if (c->buf[0] == '-') {
+        http = "HTTP/1.1 400 Bad Request\r\nContent-Type: text/html\r\n\r\n";
+    } else {
+        http = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n";
+    }
+    /* Since we limited PROTO_INLINE_MAX_SIZE, we ensure there's enough space in the
+     * buffer for the HTTP prefix (and that c->reply is never used) */
+    size_t available = sizeof(c->buf)-c->bufpos;
+    size_t httpLen = strlen(http);
+    serverAssert(available >= httpLen);
+    /* See if we need to remove any RESP protocol lengths */
+    int bytesToRemove = 0;
+    if (c->buf[0] == '$' || c->buf[0] == '*') {
+        bytesToRemove = strchr(c->buf, '\n')-c->buf+1;
+    } else if (c->buf[0] == '=') {
+        bytesToRemove = strchr(c->buf, '\n')-c->buf+4; // Skip the 3-byte "content type"
+    }
+    /* Prepend the HTTP prefix */
+    memmove(c->buf+httpLen-bytesToRemove,c->buf,c->bufpos);
+    memcpy(c->buf,http,httpLen);
+    c->bufpos += httpLen-bytesToRemove;
+
     while(clientHasPendingReplies(c)) {
         if (c->bufpos > 0) {
             nwritten = connWrite(c->conn,c->buf+c->sentlen,c->bufpos-c->sentlen);
@@ -1456,6 +1480,8 @@ int processInlineBuffer(client *c) {
     /* Split the input buffer up to the \r\n */
     querylen = newline-(c->querybuf+c->qb_pos);
     aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
+    /* Strip " HTTP/1.1" (the last 9 characters) */
+    sdsrange(aux, 0, -10);
     argv = sdssplitargs(aux,&argc);
     sdsfree(aux);
     if (argv == NULL) {
diff --git a/src/server.c b/src/server.c
index c89e9c07..acd89ddb 100644
--- a/src/server.c
+++ b/src/server.c
@@ -3345,8 +3158,8 @@ int processCommand(client *c) {
         int i;
         for (i=1; i < c->argc && sdslen(args) < 128; i++)
             args = sdscatprintf(args, "`%.*s`, ", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
-        addReplyErrorFormat(c,"unknown command `%s`, with args beginning with: %s",
-            (char*)c->argv[0]->ptr, args);
+        /* We probably hit the HTTP headers, so just close the connection */
+        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
         sdsfree(args);
         return C_OK;
     } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
diff --git a/src/server.h b/src/server.h
index c4db4278..de273159 100644
--- a/src/server.h
+++ b/src/server.h
@@ -137,7 +137,7 @@ typedef long long ustime_t; /* microsecond time type. */
 #define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */
 #define PROTO_IOBUF_LEN         (1024*16)  /* Generic I/O buffer size */
 #define PROTO_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */
-#define PROTO_INLINE_MAX_SIZE   (1024*64) /* Max size of inline reads */
+#define PROTO_INLINE_MAX_SIZE   (1024*16-256) /* Max size of inline reads (reduced to simplify output buffer handling) */
 #define PROTO_MBULK_BIG_ARG     (1024*32)
 #define LONG_STR_SIZE      21          /* Bytes needed for long -> str + '\0' */
 #define REDIS_AUTOSYNC_BYTES (1024*1024*32) /* fdatasync every 32MB */
